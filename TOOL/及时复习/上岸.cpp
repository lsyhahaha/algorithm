#include "bits/stdc++.h"
using namespace std;
#define N 100

/*typedef struct Node{//定义二叉树的存储结构
    int data;
    struct Node* left;
    struct Node* right;
}Node,*Tree;*/

/*typedef struct Node{ // 定义单链表的存储结构
    int data;
    struct Node* next;
}Node, *LNode;*/

/*
Tree build(string qx, string zx){// 前序中序构建二叉树
    if (qx.size() == 0) return NULL;
    Tree root = (Tree)malloc(sizeof(Node));
    root->data = qx[0]-'0';
*/
/*  核心代码：
 *  int pos = zx.find(qx[0]);
    root->left = build(qx.substr(1, pos), zx.substr(0,pos));
    root->right = build(qx.substr(pos+1), zx.substr(pos+1));*//*

    return root;
}*/

/*9月22日*/
        /*神奇的数字6174*/

        /*建树测试代码2017967t5*/

        /*树的遍历，建立，反正用到递归的时候就要在写判空语句，if(root==NULL),例如2017967t5*/

        /*2018941t1的k阶斐波拉契数列是什么意思，和普通的好像不一样；
         * 哦哦，知道了，普通的斐波拉契数列数列是1 1 2 3 5，每项是前面相邻两项的和；
         * 而k阶斐波拉契数列就是前k项都为0，第k项为1，以后每一项都是前k项的和*/

        /*int count = rear-front;
            while(count--){        // rear 已知在变，不能用front==raer作为判断条件
         * */

        /*小于n2的排序算法只有堆排序，合并排序，希尔排序 2017941,{A和B是长度为n的两个数组}中需要考虑*/

        /*有待解决的问题*/
        /*2017979的第二题的迪杰斯特拉算法*/
        /*2018966的第五题的弗洛伊德算法*/
        /*2017年的计专题到底有几个，到底是哪些题目？*/


/*9月23日*/
    /*2016967第六题，邻接表存储，使用深度优先算法，对图G进行拓扑排序；*/


/*9月25日*/
    /*2019941第一题，用数组创建双链表怎么创建呐？？
     * 2019967第一题也考了双链表*/
    /*好难*/

    /*软转2019年第六个，就是程序设计第4题用到了map*/