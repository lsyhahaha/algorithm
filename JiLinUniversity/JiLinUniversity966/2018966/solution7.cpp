//
// Created by 98708 on 2022/9/22.
//

/*用不完全相同的四个数字组成一个四位数，然后将组成这个四位数的四个数字重新排序，组成一个最
 * 大的数和一个最小的数，并用最大的数减去最小的数，对减得的差再重复上述操作，差不够四位数
 * 时，用零补位。不断地做下去，最后变成了一个固定不变的数：6174。卡布列卡做了大量的试验，
 * 结果不论从任何满足条件的四位数开始，最后总能变成6174。因此，卡布列卡风趣地把6174叫做卡
 * 布列卡常数。例如，从4231开始，把4231重新排列成4321和1234，两数相减得3087；再把3087
 * 重新排列成8730和0378，两数相减得8352；再把8352重新排列成8532和2358，相减得6174；
 * 再把6174重新排列成7641和1467，两数相减仍然得6174。编写程序，输入一个四位数，验证猜想。
*/

/*算法思路：
 * ①将n按照数位存放在数组中，而且按照升序排序；
 * ②求出组成的最大数和最小数；
 * ③做差，如果为6174，则退出，否则执行上述①②
 * */

#include "bits/stdc++.h"
using namespace std;

void sort(int a[4], int n){
    // 将这个四位数按照数位存放在数组中，而且按照升序排序
    int i = 0;
    while(n!=0){
        a[i++] = n%10;
        n = n/10;
    }
    for(int i=0; i<4; i++){
        for(int j=i+1; j<4; j++){
            if(a[i]>a[j]){
                int temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }
        }
    }
}

int kabulie(int n){
    int a[4];
    sort(a, n);
    int minnum=0, maxnum=0;
    // 求组合出来的最大数
    for(int i=0; i<4;i++){
        minnum = minnum*10 + a[i];
        maxnum = maxnum*10 + a[3-i];
    }

    int cha = maxnum-minnum;
    printf("%d\n", cha);

    return cha;
}

int main(){
    int cha = 3256;
    while(cha!=6174){
        cha = kabulie(cha);
    }
    return 0;
}